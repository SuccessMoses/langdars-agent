[
  {
    "contents": "open() {    if [ -z \"$1\" ]    then        echo \"Usage: open <file>\"        return    fi    # Check if the second argument is provided    if [ -n \"$2\" ]; then        # Check if the provided argument is a valid number        if ! [[ $2 =~ ^[0-9]+$ ]]; then            echo \"Usage: open <file> [<line_number>]\"            echo \"Error: <line_number> must be a number\"            return  # Exit if the line number is not valid        fi        local max_line=$(awk 'END {print NR}' $1)        if [ $2 -gt $max_line ]; then            echo \"Warning: <line_number> ($2) is greater than the number of lines in the file ($max_line)\"            echo \"Warning: Setting <line_number> to $max_line\"            local line_number=$(jq -n \"$max_line\")  # Set line number to max if greater than max        elif [ $2 -lt 1 ]; then            echo \"Warning: <line_number> ($2) is less than 1\"            echo \"Warning: Setting <line_number> to 1\"            local line_number=$(jq -n \"1\")  # Set line number to 1 if less than 1        else            local OFFSET=$(jq -n \"$WINDOW/6\" | jq 'floor')            local line_number=$(jq -n \"[$2 + $WINDOW/2 - $OFFSET, 1] | max | floor\")        fi    else        local line_number=$(jq -n \"$WINDOW/2\")  # Set default line number if not provided    fi    if [ -f \"$1\" ]; then        export CURRENT_FILE=$(realpath $1)        export CURRENT_LINE=$line_number        _constrain_line        _print    elif [ -d \"$1\" ]; then        echo \"Error: $1 is a directory. You can only open files. Use cd or ls to navigate directories.\"    else        echo \"File $1 not found\"    fi}",
    "name": "open",
    "type": "source_file"
  },
  {
    "contents": "goto() {    if [ $# -gt 1 ]; then        echo \"goto allows only one line number at a time.\"        return    fi    if [ -z \"$CURRENT_FILE\" ]    then        echo \"No file open. Use the open command first.\"        return    fi    if [ -z \"$1\" ]    then        echo \"Usage: goto <line>\"        return    fi    if ! [[ $1 =~ ^[0-9]+$ ]]    then        echo \"Usage: goto <line>\"        echo \"Error: <line> must be a number\"        return    fi    local max_line=$(awk 'END {print NR}' $CURRENT_FILE)    if [ $1 -gt $max_line ]    then        echo \"Error: <line> must be less than or equal to $max_line\"        return    fi    local OFFSET=$(jq -n \"$WINDOW/6\" | jq 'floor')    export CURRENT_LINE=$(jq -n \"[$1 + $WINDOW/2 - $OFFSET, 1] | max | floor\")    _constrain_line    _print}",
    "name": "goto",
    "type": "source_file"
  },
  {
    "contents": "scroll_down() {    if [ -z \"$CURRENT_FILE\" ]    then        echo \"No file open. Use the open command first.\"        return    fi    export CURRENT_LINE=$(jq -n \"$CURRENT_LINE + $WINDOW - $OVERLAP\")    _constrain_line    _print}",
    "name": "scroll_down",
    "type": "source_file"
  },
  {
    "contents": "scroll_up() {    if [ -z \"$CURRENT_FILE\" ]    then        echo \"No file open. Use the open command first.\"        return    fi    export CURRENT_LINE=$(jq -n \"$CURRENT_LINE - $WINDOW + $OVERLAP\")    _constrain_line    _print}",
    "name": "scroll_up",
    "type": "source_file"
  },
  {
    "contents": "create() {    if [ -z \"$1\" ]; then        echo \"Usage: create <filename>\"        return    fi    # Check if the file already exists    if [ -e \"$1\" ]; then        echo \"Error: File '$1' already exists.\"\t\topen \"$1\"        return    fi    # Create the file an empty new line    printf \"\\n\" > \"$1\"    # Use the existing open command to open the created file    open \"$1\"}",
    "name": "create",
    "type": "source_file"
  },
  {
    "contents": "submit() {    cd $ROOT    # Check if the patch file exists and is non-empty    if [ -s \"/root/test.patch\" ]; then        # Apply the patch in reverse        git apply -R < \"/root/test.patch\"    fi    git add -A    git diff --cached > model.patch    echo \"<<SUBMISSION||\"    cat model.patch    echo \"||SUBMISSION>>\"}",
    "name": "submit",
    "type": "source_file"
  },
  {
    "contents": "search_dir() {    if [ $# -eq 1 ]; then        local search_term=\"$1\"        local dir=\"./\"    elif [ $# -eq 2 ]; then        local search_term=\"$1\"        if [ -d \"$2\" ]; then            local dir=\"$2\"        else            echo \"Directory $2 not found\"            return        fi    else        echo \"Usage: search_dir <search_term> [<dir>]\"        return    fi    dir=$(realpath \"$dir\")    local matches=$(find \"$dir\" -type f ! -path '*/.*' -exec grep -nIH -- \"$search_term\" {} + | cut -d: -f1 | sort | uniq -c)    # if no matches, return    if [ -z \"$matches\" ]; then        echo \"No matches found for \\\"$search_term\\\" in $dir\"        return    fi    # Calculate total number of matches    local num_matches=$(echo \"$matches\" | awk '{sum+=$1} END {print sum}')    # calculate total number of files matched    local num_files=$(echo \"$matches\" | wc -l | awk '{$1=$1; print $0}')    # if num_files is > 100, print an error    if [ $num_files -gt 100 ]; then        echo \"More than $num_files files matched for \\\"$search_term\\\" in $dir. Please narrow your search.\"        return    fi    echo \"Found $num_matches matches for \\\"$search_term\\\" in $dir:\"    echo \"$matches\" | awk '{$2=$2; gsub(/^\\.+\\/+/, \"./\", $2); print $2 \" (\"$1\" matches)\"}'    echo \"End of matches for \\\"$search_term\\\" in $dir\"}",
    "name": "search_dir",
    "type": "source_file"
  },
  {
    "contents": "search_file() {    # Check if the first argument is provided    if [ -z \"$1\" ]; then        echo \"Usage: search_file <search_term> [<file>]\"        return    fi    # Check if the second argument is provided    if [ -n \"$2\" ]; then        # Check if the provided argument is a valid file        if [ -f \"$2\" ]; then            local file=\"$2\"  # Set file if valid        else            echo \"Usage: search_file <search_term> [<file>]\"            echo \"Error: File name $2 not found. Please provide a valid file name.\"            return  # Exit if the file is not valid        fi    else        # Check if a file is open        if [ -z \"$CURRENT_FILE\" ]; then            echo \"No file open. Use the open command first.\"            return  # Exit if no file is open        fi        local file=\"$CURRENT_FILE\"  # Set file to the current open file    fi    local search_term=\"$1\"    file=$(realpath \"$file\")    # Use grep to directly get the desired formatted output    local matches=$(grep -nH -- \"$search_term\" \"$file\")    # Check if no matches were found    if [ -z \"$matches\" ]; then        echo \"No matches found for \\\"$search_term\\\" in $file\"        return    fi    # Calculate total number of matches    local num_matches=$(echo \"$matches\" | wc -l | awk '{$1=$1; print $0}')    # calculate total number of lines matched    local num_lines=$(echo \"$matches\" | cut -d: -f1 | sort | uniq | wc -l | awk '{$1=$1; print $0}')    # if num_lines is > 100, print an error    if [ $num_lines -gt 100 ]; then        echo \"More than $num_lines lines matched for \\\"$search_term\\\" in $file. Please narrow your search.\"        return    fi    # Print the total number of matches and the matches themselves    echo \"Found $num_matches matches for \\\"$search_term\\\" in $file:\"    echo \"$matches\" | cut -d: -f1-2 | sort -u -t: -k2,2n | while IFS=: read -r filename line_number; do        echo \"$line_number:$(sed -n \"${line_number}p\" \"$file\")\"    done    echo \"End of matches for \\\"$search_term\\\" in $file\"}",
    "name": "search_file",
    "type": "source_file"
  },
  {
    "contents": "find_file() {    if [ $# -eq 1 ]; then        local file_name=\"$1\"        local dir=\"./\"    elif [ $# -eq 2 ]; then        local file_name=\"$1\"        if [ -d \"$2\" ]; then            local dir=\"$2\"        else            echo \"Directory $2 not found\"            return        fi    else        echo \"Usage: find_file <file_name> [<dir>]\"        return    fi    dir=$(realpath \"$dir\")    local matches=$(find \"$dir\" -type f -name \"$file_name\")    # if no matches, return    if [ -z \"$matches\" ]; then        echo \"No matches found for \\\"$file_name\\\" in $dir\"        return    fi    # Calculate total number of matches    local num_matches=$(echo \"$matches\" | wc -l | awk '{$1=$1; print $0}')    echo \"Found $num_matches matches for \\\"$file_name\\\" in $dir:\"    echo \"$matches\" | awk '{print $0}'}",
    "name": "find_file",
    "type": "source_file"
  },
  {
    "contents": "#!/root/miniconda3/envs/aider/bin/python\n\n# @yaml\n# signature: edit $<to_replace> $<new_content>\n# docstring: Replaces occurrence of $<to_replace> with $<new_content> in the currently open file.\n# arguments:\n#   to_replace:\n#       type: string\n#       description: The text to be replaced in the file.\n#       required: true\n#   new_content:\n#       type: string\n#       description: The new text to replace with.\n#       required: true\n\nimport os\nimport sys\nimport shutil\nimport argparse\nimport warnings\nfrom pathlib import Path\nfrom datetime import datetime\nfrom _agent_skills import edit_file_by_replace\n\n# Suppress any future warnings if necessary\nwarnings.simplefilter(\"ignore\", category=FutureWarning)\n\n# Configuration\nBACKUP_DIR = '/root/tmp/file_edit_backups'\nBACKUP_HISTORY_FILE = os.path.join(BACKUP_DIR, 'backup_history.txt')\n\ndef create_backup(file_path):\n    \"\"\"Create a backup of the file before editing.\"\"\"\n    try:\n        # Create backup directory if it doesn't exist\n        Path(BACKUP_DIR).mkdir(parents=True, exist_ok=True)\n        \n        # Create backup history file if it doesn't exist\n        if not os.path.exists(BACKUP_HISTORY_FILE):\n            Path(BACKUP_HISTORY_FILE).touch()\n            \n        # Generate backup filename with timestamp\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        backup_filename = f\"{Path(file_path).stem}_{timestamp}{Path(file_path).suffix}\"\n        backup_path = os.path.join(BACKUP_DIR, backup_filename)\n        \n        # Create backup\n        shutil.copy2(file_path, backup_path)\n        \n        # Record backup in history file\n        with open(BACKUP_HISTORY_FILE, 'a') as f:\n            f.write(f\"{backup_path}::{file_path}\\n\")\n            \n    except Exception as e:\n        print(f\"Warning: Failed to create backup: {e}\", file=sys.stderr)\n\ndef main():\n    # Check if CURRENT_FILE environment variable is set\n    current_file = os.environ.get('CURRENT_FILE')\n    if not current_file:\n        print('No file open. Use the `open` command first.')\n        sys.exit(1)\n\n    os.environ['ENABLE_AUTO_LINT'] = 'true'\n\n    # Parse arguments\n    parser = argparse.ArgumentParser(\n        description='Edit a file by replacing specific content based on diffs.'\n    )\n    parser.add_argument('to_replace', type=str, help='The text to be replaced in the file.')\n    parser.add_argument('new_content', type=str, help='The new text to replace with.')\n    args = parser.parse_args()\n\n    to_replace = args.to_replace\n    new_content = args.new_content\n\n    # Validate arguments\n    if not to_replace:\n        print(\"Error: 'to_replace' must not be empty.\")\n        print(\"Usage: edit $<to_replace> $<new_content>\")\n        sys.exit(1)\n    if to_replace == new_content:\n        print(\"Error: 'to_replace' and 'new_content' must be different.\")\n        print(\"Usage: edit $<to_replace> $<new_content>\")\n        sys.exit(1)\n\n    # Create backup before editing\n    create_backup(current_file)\n\n    # Call the edit function\n    try:\n        edit_file_by_replace(current_file, to_replace, new_content)\n    except Exception as e:\n        print(f\"Error editing file: {e}\", file=sys.stderr)\n        print(\"Usage: edit $<to_replace> $<new_content>\")\n        sys.exit(1)\n\nif __name__ == '__main__':\n    main()",
    "name": "edit",
    "type": "script"
  },
  {
    "contents": "#!/root/miniconda3/envs/aider/bin/python\n\n# @yaml\n# signature: undo_edit [file_path]\n# docstring: Reverts the last edit made to the specified file. If no file is provided, reverts the last edit on the currently open file.\n# arguments:\n#   file_path:\n#     type: string\n#     description: The path to the file to undo the last edit for.\n#     required: false\n\nimport os\nimport sys\nimport warnings\nimport shutil\nimport argparse\nfrom pathlib import Path\nfrom typing import List, Tuple, Optional\n\n# Suppress any future warnings if necessary\nwarnings.simplefilter(\"ignore\", category=FutureWarning)\n\n# Configuration\nBACKUP_DIR = '/root/tmp/file_edit_backups'\nBACKUP_HISTORY_FILE = os.path.join(BACKUP_DIR, 'backup_history.txt')\n\nclass BackupManager:\n    @staticmethod\n    def get_file_backups(file_path: str) -> List[Tuple[str, str]]:\n        \"\"\"Get all backups for a specific file.\"\"\"\n        if not os.path.exists(BACKUP_HISTORY_FILE):\n            return []\n\n        backups = []\n        with open(BACKUP_HISTORY_FILE, 'r') as f:\n            for line in f:\n                if line.strip():\n                    try:\n                        backup_path, orig_path = line.strip().split(\"::\")\n                        if orig_path == file_path and os.path.exists(backup_path):\n                            backups.append((backup_path, orig_path))\n                    except ValueError:\n                        continue\n        return backups\n\n    @staticmethod\n    def restore_backup(backup_path: str, target_file: str) -> bool:\n        \"\"\"Restore a file from its backup.\"\"\"\n        try:\n            if not os.path.exists(backup_path):\n                return False\n            shutil.copy2(backup_path, target_file)\n            return True\n        except Exception:\n            return False\n\n    @staticmethod\n    def update_history(entries: List[str]) -> None:\n        \"\"\"Update the backup history file.\"\"\"\n        with open(BACKUP_HISTORY_FILE, 'w') as f:\n            f.writelines(entries)\n\n    @staticmethod\n    def cleanup_old_backups(file_path: str, keep_last: int = 5) -> None:\n        \"\"\"Remove old backups keeping only the specified number of recent ones.\"\"\"\n        backups = BackupManager.get_file_backups(file_path)\n        if len(backups) <= keep_last:\n            return\n\n        # Remove older backups\n        for backup_path, _ in backups[:-keep_last]:\n            try:\n                os.remove(backup_path)\n            except OSError:\n                pass\n\ndef undo_last_edit(file_path: str) -> bool:\n    \"\"\"\n    Undo the last edit for a specific file.\n    Returns True if successful, False otherwise.\n    \"\"\"\n    try:\n        # Get all backups for the file\n        backups = BackupManager.get_file_backups(file_path)\n        if not backups:\n            print(f\"No edits have been made to the file: {file_path}\")\n            return False\n\n        # Get the most recent backup\n        last_backup, original_file = backups[-1]\n\n        # Verify files exist\n        if not os.path.exists(last_backup):\n            print(f\"Backup file not found: {last_backup}\")\n            return False\n\n        if not os.path.exists(original_file):\n            print(f\"Original file not found: {original_file}\")\n            return False\n\n        # Restore from backup\n        if not BackupManager.restore_backup(last_backup, original_file):\n            print(\"Failed to restore from backup\")\n            return False\n\n        # Update backup history\n        with open(BACKUP_HISTORY_FILE, 'r') as f:\n            all_entries = f.readlines()\n        \n        entries_to_keep = [\n            entry for entry in all_entries \n            if entry.strip() != f\"{last_backup}::{original_file}\"\n        ]\n        \n        BackupManager.update_history(entries_to_keep)\n\n        # Cleanup old backups\n        BackupManager.cleanup_old_backups(file_path)\n\n        print(f\"Successfully restored {file_path} to previous version\")\n        return True\n\n    except Exception as e:\n        print(f\"Error during undo operation: {e}\", file=sys.stderr)\n        return False\n\ndef main():\n    # Parse arguments\n    parser = argparse.ArgumentParser(\n        description='Reverts the last edit made to the specified file.'\n    )\n    parser.add_argument('file_path', nargs='?', default=None, \n                       help='The path to the file to undo the last edit for.')\n    args = parser.parse_args()\n\n    # Determine the file to undo\n    file_path = args.file_path\n    if not file_path:\n        file_path = os.environ.get('CURRENT_FILE')\n        if not file_path:\n            print('No file specified and no file open. Use the `open` command first or specify a file.')\n            sys.exit(1)\n\n    # Attempt to undo last edit\n    if not undo_last_edit(file_path):\n        sys.exit(1)\n\nif __name__ == '__main__':\n    main()",
    "name": "undo_edit",
    "type": "script"
  },
  {
    "contents": "#!/root/miniconda3/envs/aider/bin/python\n\n# @yaml\n# signature: insert <line_number> $<content>\n# docstring: Inserts $<content> at the given <line_number> in the currently open file.\n# arguments:\n#   line_number:\n#       type: int\n#       description: The line number where the content should be inserted.\n#       required: true\n#   content:\n#       type: string\n#       description: The content to insert at the specified line number.\n#       required: true\n\nimport os\nimport re\nimport sys\nimport shutil\nimport argparse\nimport warnings\nfrom pathlib import Path\nfrom datetime import datetime\n\n# Suppress any future warnings if necessary\nwarnings.simplefilter(\"ignore\", category=FutureWarning)\n\nfrom _agent_skills import insert_content_at_line\n\n# Configuration\nBACKUP_DIR = '/root/tmp/file_edit_backups'\nBACKUP_HISTORY_FILE = os.path.join(BACKUP_DIR, 'backup_history.txt')\n\ndef create_backup(file_path):\n    \"\"\"Create a backup of the file before editing.\"\"\"\n    try:\n        # Create backup directory if it doesn't exist\n        Path(BACKUP_DIR).mkdir(parents=True, exist_ok=True)\n        \n        # Create backup history file if it doesn't exist\n        if not os.path.exists(BACKUP_HISTORY_FILE):\n            Path(BACKUP_HISTORY_FILE).touch()\n            \n        # Generate backup filename with timestamp\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        backup_filename = f\"{Path(file_path).stem}_{timestamp}{Path(file_path).suffix}\"\n        backup_path = os.path.join(BACKUP_DIR, backup_filename)\n        \n        # Create backup\n        shutil.copy2(file_path, backup_path)\n        \n        # Record backup in history file\n        with open(BACKUP_HISTORY_FILE, 'a') as f:\n            f.write(f\"{backup_path}::{file_path}\\n\")\n            \n    except Exception as e:\n        print(f\"Warning: Failed to create backup: {e}\", file=sys.stderr)\n\ndef main():\n    # Check if CURRENT_FILE environment variable is set\n    current_file = os.environ.get('CURRENT_FILE')\n    if not current_file:\n        print('No file open. Use the `open` command first.')\n        sys.exit(1)\n\n    # Set ENABLE_AUTO_LINT environment variable\n    os.environ['ENABLE_AUTO_LINT'] = 'true'\n\n    # Parse arguments\n    parser = argparse.ArgumentParser(\n        description='Inserts $<content> at the given <line_number> in the currently open file.'\n    )\n    parser.add_argument('line_number', type=int, help='The line number where the content should be inserted.')\n    parser.add_argument('content', type=str, help='The content to insert at the specified line number.')\n    args = parser.parse_args()\n\n    line_number = args.line_number\n    content = args.content\n\n    # Validate arguments\n    if line_number <= 0:\n        print(\"Error: 'line_number' must be a valid integer.\")\n        print(\"Usage: insert <line_number> $<content>\")\n        sys.exit(1)\n    if not content:\n        print(\"Error: 'content' must not be empty.\")\n        print(\"Usage: insert <line_number> $<content>\")\n        sys.exit(1)\n\n    # Create backup before editing\n    create_backup(current_file)\n\n    # Call the insert function\n    try:\n        insert_content_at_line(current_file, line_number, content)\n    except Exception as e:\n        print(f\"Error inserting content: {e}\", file=sys.stderr)\n        print(\"Usage: insert <line_number> $<content>\")\n        sys.exit(1)\n\nif __name__ == '__main__':\n    main()",
    "name": "insert",
    "type": "script"
  },
  {
    "contents": "#!/root/miniconda3/envs/aider/bin/python\n\n# @yaml\n# signature: append $<content>\n# docstring: Appends $<content> to the end of the currently open file.\n# arguments:\n#   content:\n#       type: string\n#       description: The content to append to the end of the file.\n#       required: true\n\nimport os\nimport sys\nimport shutil\nimport argparse\nimport warnings\nfrom pathlib import Path\nfrom datetime import datetime\n\n# Suppress any future warnings if necessary\nwarnings.simplefilter(\"ignore\", category=FutureWarning)\n\nfrom _agent_skills import append_file\n\n# Configuration\nBACKUP_DIR = '/root/tmp/file_edit_backups'\nBACKUP_HISTORY_FILE = os.path.join(BACKUP_DIR, 'backup_history.txt')\n\ndef create_backup(file_path):\n    \"\"\"Create a backup of the file before editing.\"\"\"\n    try:\n        # Create backup directory if it doesn't exist\n        Path(BACKUP_DIR).mkdir(parents=True, exist_ok=True)\n        \n        # Create backup history file if it doesn't exist\n        if not os.path.exists(BACKUP_HISTORY_FILE):\n            Path(BACKUP_HISTORY_FILE).touch()\n            \n        # Generate backup filename with timestamp\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        backup_filename = f\"{Path(file_path).stem}_{timestamp}{Path(file_path).suffix}\"\n        backup_path = os.path.join(BACKUP_DIR, backup_filename)\n        \n        # Create backup\n        shutil.copy2(file_path, backup_path)\n        \n        # Record backup in history file\n        with open(BACKUP_HISTORY_FILE, 'a') as f:\n            f.write(f\"{backup_path}::{file_path}\\n\")\n            \n    except Exception as e:\n        print(f\"Warning: Failed to create backup: {e}\", file=sys.stderr)\n\ndef main():\n    # Check if CURRENT_FILE environment variable is set\n    current_file = os.environ.get('CURRENT_FILE')\n    if not current_file:\n        print('No file open. Use the `open` command first.')\n        sys.exit(1)\n\n    # Set ENABLE_AUTO_LINT environment variable\n    os.environ['ENABLE_AUTO_LINT'] = 'true'\n\n    # Parse arguments\n    parser = argparse.ArgumentParser(\n        description='Appends $<content> to the end of the currently open file.'\n    )\n    parser.add_argument('content', type=str, help='The content to append to the end of the file.')\n    args = parser.parse_args()\n\n    content = args.content\n\n    # Validate content\n    if not content:\n        print(\"Error: 'content' must not be empty.\")\n        print(\"Usage: append $<content>\")\n        sys.exit(1)\n\n    # Create backup before editing\n    create_backup(current_file)\n\n    # Call the append function\n    try:\n        append_file(current_file, content)\n    except Exception as e:\n        print(f\"Error appending content: {e}\", file=sys.stderr)\n        print(\"Usage: append $<content>\")\n        sys.exit(1)\n\nif __name__ == '__main__':\n    main()\n",
    "name": "append",
    "type": "script"
  },
  {
    "contents": "#!/usr/bin/env python3\n\n# @yaml\n# signature: execute_ipython $<code>\n# docstring: Executes Python code in a persistent cell, returning its output. Variables persist between executions.\n# arguments:\n#   code:\n#       type: string\n#       description: Python code to execute in the cell.\n#       required: true\n\nimport sys\nimport os\nimport argparse\nimport socket\nimport pickle\n\n# Path to the Unix domain socket\nSOCKET_FILE = '/tmp/python_cell_socket'\n\ndef start_server_process():\n    \"\"\"Start the server process if it's not already running.\"\"\"\n    import subprocess\n    import time\n    server_script = 'python_cell_server'\n\n    try:\n        # Start the server script directly, assuming it's in the PATH\n        subprocess.Popen([server_script])\n    except FileNotFoundError:\n        print(f\"Error: Server script '{server_script}' not found in PATH.\", file=sys.stderr)\n        sys.exit(1)\n    except Exception as e:\n        print(f\"Error starting server process: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    # Wait a moment for the server to start\n    time.sleep(0.5)\n\ndef send_code_to_server(code: str):\n    \"\"\"Send code to the server and get the output.\"\"\"\n    # Ensure the server is running\n    if not os.path.exists(SOCKET_FILE):\n        start_server_process()\n\n    # Connect to the server\n    client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    try:\n        client.connect(SOCKET_FILE)\n    except socket.error as e:\n        print(f\"Error connecting to server: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    # Send the length of the code\n    code_bytes = code.encode('utf-8')\n    client.sendall(len(code_bytes).to_bytes(8, byteorder='big'))\n    # Send the actual code\n    client.sendall(code_bytes)\n\n    # Receive the length of the response\n    response_length_bytes = client.recv(8)\n    if not response_length_bytes:\n        print(\"No response from server.\", file=sys.stderr)\n        sys.exit(1)\n    response_length = int.from_bytes(response_length_bytes, byteorder='big')\n    # Receive the actual response\n    response_bytes = b''\n    while len(response_bytes) < response_length:\n        chunk = client.recv(response_length - len(response_bytes))\n        if not chunk:\n            break\n        response_bytes += chunk\n    response = pickle.loads(response_bytes)\n    client.close()\n    return response\n\ndef format_output(output: str, errors: str) -> None:\n    \"\"\"Format and print the output from the cell execution.\"\"\"\n    if output.strip():\n        print(\"Output:\")\n        print(\"-\" * 50)\n        print(output.rstrip())\n        \n    if errors.strip():\n        print(\"\\nErrors:\", file=sys.stderr)\n        print(\"-\" * 50, file=sys.stderr)\n        print(errors.rstrip(), file=sys.stderr)\n\ndef main():\n    # Set up argument parser to take code as a command-line argument\n    parser = argparse.ArgumentParser(\n        description=\"Executes Python code in a persistent cell.\"\n    )\n    parser.add_argument(\n        \"code\", \n        type=str, \n        nargs='?', \n        help=\"The Python code to execute in the cell. If not provided, reads from stdin.\"\n    )\n    args = parser.parse_args()\n    \n    if args.code:\n        code = args.code\n    else:\n        # Read code from stdin\n        code = sys.stdin.read()\n    \n    # Check if the provided code is empty or only contains whitespace\n    if not code.strip():\n        print(\"Error: 'code' must not be empty.\")\n        print(\"Usage: execute_ipython $<code>\")\n        sys.exit(1)\n    \n    # Send the code to the server and get the response\n    response = send_code_to_server(code)\n    output = response.get('output', '')\n    errors = response.get('errors', '')\n\n    # Format and display the output\n    format_output(output, errors)\n    \n    # Exit with error code if there were any errors\n    if errors.strip():\n        sys.exit(1)\n\nif __name__ == '__main__':\n    main()\n",
    "name": "execute_ipython",
    "type": "script"
  },
  {
    "contents": "#!/usr/bin/env python3\n\n# @yaml\n# signature: execute_server <command>\n# docstring: To run long-lived processes such as server or daemon. It runs the command in the background and provides a log of the output.\n# arguments:\n#   command:\n#       type: string\n#       description: Bash command to execute in the shell.\n#       required: true\n# special_commands:\n#   - get_logs: Retrieves the last 100 lines of the server log.\n#   - stop: Stops the background Bash server process.\n\nimport sys\nimport os\nimport argparse\nimport socket\nimport pickle\nimport errno\n\nSOCKET_FILE = '/tmp/bash_command_socket'\n\ndef start_server_process():\n    \"\"\"Start the Bash server process if it's not already running.\"\"\"\n    import subprocess\n    import time\n    server_script = 'bash_server'\n\n    try:\n        subprocess.Popen([server_script])\n    except FileNotFoundError:\n        print(f\"Error: Server script '{server_script}' not found in PATH.\", file=sys.stderr)\n        sys.exit(1)\n    except Exception as e:\n        print(f\"Error starting server process: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    # Wait for the server to start\n    timeout = 5  # seconds\n    start_time = time.time()\n    while not os.path.exists(SOCKET_FILE):\n        if time.time() - start_time > timeout:\n            print(\"Error: Server did not start within expected time.\", file=sys.stderr)\n            sys.exit(1)\n        time.sleep(0.1)\n\ndef send_command_to_server(command: str):\n    \"\"\"Send a command to the server and get the output.\"\"\"\n    if not os.path.exists(SOCKET_FILE):\n        start_server_process()\n\n    client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    try:\n        client.connect(SOCKET_FILE)\n    except socket.error as e:\n        if e.errno in (errno.ENOENT, errno.ECONNREFUSED):\n            print(\"Server not running, starting server...\")\n            start_server_process()\n            try:\n                client.connect(SOCKET_FILE)\n            except socket.error as e:\n                print(f\"Error connecting to server after restart: {e}\", file=sys.stderr)\n                sys.exit(1)\n        else:\n            print(f\"Error connecting to server: {e}\", file=sys.stderr)\n            sys.exit(1)\n\n    try:\n        # Send the command\n        command_bytes = command.encode('utf-8')\n        client.sendall(len(command_bytes).to_bytes(8, byteorder='big'))\n        client.sendall(command_bytes)\n\n        # Receive the response length\n        response_length_bytes = client.recv(8)\n        if not response_length_bytes:\n            print(\"No response from server.\", file=sys.stderr)\n            sys.exit(1)\n        response_length = int.from_bytes(response_length_bytes, byteorder='big')\n\n        # Read the response\n        response_bytes = b''\n        while len(response_bytes) < response_length:\n            chunk = client.recv(min(response_length - len(response_bytes), 4096))\n            if not chunk:\n                break\n            response_bytes += chunk\n        response = pickle.loads(response_bytes)\n        client.close()\n        return response\n    except Exception as e:\n        print(f\"Error during communication with server: {e}\", file=sys.stderr)\n        client.close()\n        sys.exit(1)\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Executes Bash commands through a persistent server.\"\n    )\n    parser.add_argument(\n        \"command\",\n        type=str,\n        help=\"The Bash command to execute, or 'stop'/'get_logs' for special commands.\"\n    )\n    args = parser.parse_args()\n\n    # Send the command to the server\n    response = send_command_to_server(args.command)\n    output = response.get('output', '')\n    errors = response.get('errors', '')\n\n    if output.strip():\n        print(\"Output:\")\n        print(\"-\" * 50)\n        print(output.rstrip())\n\n    if errors.strip():\n        print(\"\\nErrors:\", file=sys.stderr)\n        print(\"-\" * 50, file=sys.stderr)\n        print(errors.rstrip(), file=sys.stderr)\n        sys.exit(1)\n\nif __name__ == '__main__':\n    main()",
    "name": "execute_server",
    "type": "script"
  },
  {
    "contents": "_print() {    local total_lines=$(awk 'END {print NR}' $CURRENT_FILE)    echo \"[File: $(realpath $CURRENT_FILE) ($total_lines lines total)]\"    lines_above=$(jq -n \"$CURRENT_LINE - $WINDOW/2\" | jq '[0, .] | max | floor')    lines_below=$(jq -n \"$total_lines - $CURRENT_LINE - $WINDOW/2\" | jq '[0, .] | max | round')    if [ $lines_above -gt 0 ]; then        echo \"($lines_above more lines above)\"    fi    cat $CURRENT_FILE | grep -n $ | head -n $(jq -n \"[$CURRENT_LINE + $WINDOW/2, $WINDOW/2] | max | floor\") | tail -n $(jq -n \"$WINDOW\")    if [ $lines_below -gt 0 ]; then        echo \"($lines_below more lines below)\"    fi}",
    "name": "_print",
    "type": "utility"
  },
  {
    "contents": "_constrain_line() {    if [ -z \"$CURRENT_FILE\" ]    then        echo \"No file open. Use the open command first.\"        return    fi    local max_line=$(awk 'END {print NR}' $CURRENT_FILE)    local half_window=$(jq -n \"$WINDOW/2\" | jq 'floor')    export CURRENT_LINE=$(jq -n \"[$CURRENT_LINE, $max_line - $half_window] | min\")    export CURRENT_LINE=$(jq -n \"[$CURRENT_LINE, $half_window] | max\")}",
    "name": "_constrain_line",
    "type": "utility"
  }
]